-- Incremental migration: public individual books + user book media
-- Safe to run multiple times.

-- Allow public individual books even when profile is followers-only.
create or replace function public.is_public_profile(target uuid)
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.profiles p
    where p.id = target
      and p.visibility = 'public'
  );
$$;

create or replace function public.can_view_user_book(book public.user_books)
returns boolean
language sql
stable
as $$
  select
    (auth.uid() = book.owner_id)
    or (book.visibility = 'public')
    or (
      book.visibility = 'followers_only'
      and auth.uid() is not null
      and public.is_approved_follower(auth.uid(), book.owner_id)
    )
    or (
      book.visibility = 'inherit'
      and (
        public.is_public_profile(book.owner_id)
        or (auth.uid() is not null and public.is_approved_follower(auth.uid(), book.owner_id))
      )
    );
$$;

create or replace function public.has_public_books(target uuid)
returns boolean
language sql
stable
security definer
set search_path = public
as $$
  select exists (
    select 1
    from public.user_books ub
    where ub.owner_id = target
      and ub.visibility = 'public'
  );
$$;

create or replace function public.can_view_profile(target uuid)
returns boolean
language sql
stable
as $$
  select
    (auth.uid() = target)
    or public.is_public_profile(target)
    or (auth.uid() is not null and public.is_approved_follower(auth.uid(), target))
    or public.has_public_books(target);
$$;

-- Allow authenticated clients to insert shared edition metadata.
drop policy if exists "editions_insert_authed" on public.editions;
create policy "editions_insert_authed"
on public.editions
for insert
with check (auth.uid() is not null);

-- User-provided media (additional images / optional cover override later).
create table if not exists public.user_book_media (
  id bigint generated by default as identity primary key,
  user_book_id bigint not null references public.user_books (id) on delete cascade,
  kind text not null check (kind in ('cover', 'image')),
  storage_path text not null unique,
  caption text,
  created_at timestamptz not null default now()
);

create index if not exists user_book_media_user_book_id_idx on public.user_book_media (user_book_id);

alter table public.user_book_media enable row level security;

drop policy if exists "user_book_media_select_viewable" on public.user_book_media;
create policy "user_book_media_select_viewable"
on public.user_book_media
for select
using (
  exists (
    select 1
    from public.user_books ub
    where ub.id = user_book_id
      and public.can_view_user_book(ub)
  )
);

drop policy if exists "user_book_media_insert_owner" on public.user_book_media;
create policy "user_book_media_insert_owner"
on public.user_book_media
for insert
with check (
  exists (
    select 1
    from public.user_books ub
    where ub.id = user_book_id
      and ub.owner_id = auth.uid()
  )
);

drop policy if exists "user_book_media_update_owner" on public.user_book_media;
create policy "user_book_media_update_owner"
on public.user_book_media
for update
using (
  exists (
    select 1
    from public.user_books ub
    where ub.id = user_book_id
      and ub.owner_id = auth.uid()
  )
)
with check (
  exists (
    select 1
    from public.user_books ub
    where ub.id = user_book_id
      and ub.owner_id = auth.uid()
  )
);

drop policy if exists "user_book_media_delete_owner" on public.user_book_media;
create policy "user_book_media_delete_owner"
on public.user_book_media
for delete
using (
  exists (
    select 1
    from public.user_books ub
    where ub.id = user_book_id
      and ub.owner_id = auth.uid()
  )
);

-- Note: Supabase Storage `storage.objects` is not always editable from the SQL editor role.
-- Create the `user-book-media` bucket and its Storage policies in the Supabase Dashboard instead.
